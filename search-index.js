var searchIndex = {};
searchIndex['bencode'] = {"items":[[0,"","bencode","Encoding and decoding for the bencode format.",null,null],[3,"Decoder","","Decodes values from a stream of bytes.",null,null],[3,"Encoder","","Encodes values into a stream of bytes.",null,null],[3,"ByteStr","","A borrowed byte string.",null,null],[3,"ByteString","","An owned byte string.",null,null],[3,"Hash","","Contains the SHA1 hash of the decoded value.",null,null],[4,"DecodeError","","Represents an error in a decoding operation.",null,null],[13,"Eof","","End of bytes reached before expected",0,null],[13,"ExtraneousData","","Extraneous data at the end of the stream",0,null],[13,"InvalidByte","","Unexpected byte",0,null],[13,"InvalidDict","","Duplicate or out-of-order key in a dict",0,null],[13,"InvalidNumber","","Invalid formatted number",0,null],[13,"InvalidUtf8","","Invalid UTF-8 in a string",0,null],[13,"MissingField","","Field not found while decoding `struct`",0,null],[13,"UnexpectedByte","","Unexpected byte encountered",0,null],[12,"expected","bencode::DecodeError","Byte expected",0,null],[12,"found","","Byte found",0,null],[4,"EncodeError","bencode","Represents an error in an encoding operation.",null,null],[4,"Value","","Contains any valid bencode value.",null,null],[13,"Integer","","Integer value",1,null],[13,"Bytes","","Byte string value",1,null],[13,"String","","UTF-8 string value",1,null],[13,"List","","List value",1,null],[13,"Dict","","Dictionary value",1,null],[5,"decode","","Decodes a value from a stream of bytes.",null,null],[5,"encode","","Encodes a value into a stream of bytes.",null,{"inputs":[{"name":"t"}],"output":{"name":"result"}}],[8,"Decodable","","Represents a value decodable from a bencoded stream.",null,null],[10,"decode","","",2,{"inputs":[{"name":"decodable"},{"name":"decoder"}],"output":{"name":"result"}}],[8,"Encodable","","Represents a value encodable to a bencoded stream.",null,null],[10,"encode","","",3,{"inputs":[{"name":"encodable"},{"name":"encoder"}],"output":{"name":"result"}}],[8,"Integer","","An integer type that can be encoded and decoded.",null,null],[11,"clone","","",4,{"inputs":[{"name":"decoder"}],"output":{"name":"decoder"}}],[11,"new","","Constructs a new `Decoder`, reading from the given byte string.",4,null],[11,"remaining","","Returns the number of bytes remaining in the stream.",4,{"inputs":[{"name":"decoder"}],"output":{"name":"usize"}}],[11,"position","","Returns the current position of the cursor.",4,{"inputs":[{"name":"decoder"}],"output":{"name":"u64"}}],[11,"set_position","","Sets the current position of the cursor.",4,{"inputs":[{"name":"decoder"},{"name":"u64"}],"output":null}],[11,"finish","","Returns an error if there is data remaining in the stream.",4,{"inputs":[{"name":"decoder"}],"output":{"name":"result"}}],[11,"read","","Reads a series of bytes from the stream equal to `buf.len()`.\nIf fewer bytes are available to read, an error is returned.",4,null],[11,"read_byte","","Reads a single byte from the stream. If no bytes are available to read,\nan error is returned.",4,{"inputs":[{"name":"decoder"}],"output":{"name":"result"}}],[11,"peek_byte","","Reads a single byte from the stream without advancing the cursor.",4,{"inputs":[{"name":"decoder"}],"output":{"name":"result"}}],[11,"peek_bytes","","Returns a slice of bytes without advancing the cursor.\nIf fewer than `n` bytes are available, an error is returned.",4,{"inputs":[{"name":"decoder"},{"name":"usize"}],"output":{"name":"result"}}],[11,"read_integer","","Reads an integer value from the stream.",4,{"inputs":[{"name":"decoder"}],"output":{"name":"result"}}],[11,"read_number","","Reads a number from the stream.\nThis does not include the `i` prefix and `e` suffix.",4,{"inputs":[{"name":"decoder"}],"output":{"name":"result"}}],[11,"read_bytes","","Reads a byte string from the stream.",4,{"inputs":[{"name":"decoder"}],"output":{"name":"result"}}],[11,"read_str","","Reads a UTF-8 encoded string from the stream.",4,{"inputs":[{"name":"decoder"}],"output":{"name":"result"}}],[11,"read_dict","","Reads a key value mapping from the stream.",4,{"inputs":[{"name":"decoder"}],"output":{"name":"result"}}],[11,"read_list","","Reads a series of values from the stream.",4,{"inputs":[{"name":"decoder"}],"output":{"name":"result"}}],[11,"read_struct","","Reads a key value mapping from the stream as a `struct`.",4,{"inputs":[{"name":"decoder"},{"name":"f"}],"output":{"name":"result"}}],[11,"read_field","","Reads a single field from the stream.",4,{"inputs":[{"name":"decoder"},{"name":"str"}],"output":{"name":"result"}}],[11,"read_option","","Reads an optional field from the stream.",4,{"inputs":[{"name":"decoder"},{"name":"str"}],"output":{"name":"result"}}],[11,"skip_item","","Advances the cursor beyond the current value.",4,{"inputs":[{"name":"decoder"}],"output":{"name":"result"}}],[11,"skip","","Advances the cursor `n` bytes.",4,{"inputs":[{"name":"decoder"},{"name":"usize"}],"output":{"name":"result"}}],[11,"skip_while","","Advance bytes in the stream until `predicate` returns `false`.",4,{"inputs":[{"name":"decoder"},{"name":"p"}],"output":{"name":"result"}}],[11,"read_while","","Reads bytes from the stream until `predicate` returns `false`.",4,{"inputs":[{"name":"decoder"},{"name":"p"}],"output":{"name":"result"}}],[11,"expect","","Returns an error if the next byte is not `byte`.",4,{"inputs":[{"name":"decoder"},{"name":"u8"}],"output":{"name":"result"}}],[11,"eq","","",0,{"inputs":[{"name":"decodeerror"},{"name":"decodeerror"}],"output":{"name":"bool"}}],[11,"ne","","",0,{"inputs":[{"name":"decodeerror"},{"name":"decodeerror"}],"output":{"name":"bool"}}],[11,"fmt","","",0,{"inputs":[{"name":"decodeerror"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",0,{"inputs":[{"name":"decodeerror"}],"output":{"name":"decodeerror"}}],[11,"fmt","","",0,{"inputs":[{"name":"decodeerror"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",5,{"inputs":[{"name":"encoder"}],"output":{"name":"encoder"}}],[11,"new","","Constructs a new `Encoder`.",5,{"inputs":[{"name":"encoder"}],"output":{"name":"encoder"}}],[11,"into_bytes","","Consumes the `Encoder` and returns the encoded bytes.",5,{"inputs":[{"name":"encoder"}],"output":{"name":"vec"}}],[11,"write_byte","","Writes a single byte to the stream.",5,{"inputs":[{"name":"encoder"},{"name":"u8"}],"output":{"name":"result"}}],[11,"write","","Writes a series of bytes to the stream.",5,null],[11,"write_integer","","Writes an integer value to the stream.",5,{"inputs":[{"name":"encoder"},{"name":"t"}],"output":{"name":"result"}}],[11,"write_number","","Writes a number to the stream.\nThis does not include `i` prefix and `e` suffix.",5,{"inputs":[{"name":"encoder"},{"name":"t"}],"output":{"name":"result"}}],[11,"write_bytes","","Writes a byte string to the stream.",5,null],[11,"write_str","","Writes a UTF-8 encoded string to the stream.",5,{"inputs":[{"name":"encoder"},{"name":"str"}],"output":{"name":"result"}}],[11,"write_dict","","Writes a key value mapping to the stream.",5,{"inputs":[{"name":"encoder"},{"name":"btreemap"}],"output":{"name":"result"}}],[11,"write_list","","",5,null],[11,"write_struct","","Writes a key value mapping from a `struct` to the stream.",5,{"inputs":[{"name":"encoder"},{"name":"f"}],"output":{"name":"result"}}],[11,"write_field","","Writes a single field to the stream.",5,{"inputs":[{"name":"encoder"},{"name":"str"},{"name":"t"}],"output":{"name":"result"}}],[11,"write_option","","Writes an optional field to the stream.",5,{"inputs":[{"name":"encoder"},{"name":"str"},{"name":"option"}],"output":{"name":"result"}}],[11,"eq","","",6,{"inputs":[{"name":"encodeerror"},{"name":"encodeerror"}],"output":{"name":"bool"}}],[11,"ne","","",6,{"inputs":[{"name":"encodeerror"},{"name":"encodeerror"}],"output":{"name":"bool"}}],[11,"fmt","","",6,{"inputs":[{"name":"encodeerror"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",6,{"inputs":[{"name":"encodeerror"}],"output":{"name":"encodeerror"}}],[11,"from_bytes","","Returns a byte slice as a `&ByteStr`.",7,null],[11,"as_bytes","","Returns the byte string as a slice.",7,null],[11,"as_str","","Returns the byte string as a `&str`, if it contains only valid UTF-8.",7,{"inputs":[{"name":"bytestr"}],"output":{"name":"option"}}],[11,"fmt","","",7,{"inputs":[{"name":"bytestr"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"partial_cmp","","",8,{"inputs":[{"name":"bytestring"},{"name":"bytestring"}],"output":{"name":"option"}}],[11,"lt","","",8,{"inputs":[{"name":"bytestring"},{"name":"bytestring"}],"output":{"name":"bool"}}],[11,"le","","",8,{"inputs":[{"name":"bytestring"},{"name":"bytestring"}],"output":{"name":"bool"}}],[11,"gt","","",8,{"inputs":[{"name":"bytestring"},{"name":"bytestring"}],"output":{"name":"bool"}}],[11,"ge","","",8,{"inputs":[{"name":"bytestring"},{"name":"bytestring"}],"output":{"name":"bool"}}],[11,"cmp","","",8,{"inputs":[{"name":"bytestring"},{"name":"bytestring"}],"output":{"name":"ordering"}}],[11,"eq","","",8,{"inputs":[{"name":"bytestring"},{"name":"bytestring"}],"output":{"name":"bool"}}],[11,"ne","","",8,{"inputs":[{"name":"bytestring"},{"name":"bytestring"}],"output":{"name":"bool"}}],[11,"fmt","","",8,{"inputs":[{"name":"bytestring"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",8,{"inputs":[{"name":"bytestring"}],"output":{"name":"bytestring"}}],[11,"as_ref","","",8,{"inputs":[{"name":"bytestring"}],"output":{"name":"bytestr"}}],[6,"Target","","",null,null],[11,"deref","","",8,{"inputs":[{"name":"bytestring"}],"output":{"name":"bytestr"}}],[11,"to_hex","","Returns the SHA1 hash as a string of hexadecimal digits.",9,{"inputs":[{"name":"hash"}],"output":{"name":"string"}}],[11,"decode","","",9,{"inputs":[{"name":"hash"},{"name":"decoder"}],"output":{"name":"result"}}],[11,"eq","","",1,{"inputs":[{"name":"value"},{"name":"value"}],"output":{"name":"bool"}}],[11,"ne","","",1,{"inputs":[{"name":"value"},{"name":"value"}],"output":{"name":"bool"}}],[11,"fmt","","",1,{"inputs":[{"name":"value"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",1,{"inputs":[{"name":"value"}],"output":{"name":"value"}}],[11,"into_bytes","","Converts a `Bytes` or `String` value into `Vec<u8>`.\nOtherwise, returns `Err(self)`.",1,{"inputs":[{"name":"value"}],"output":{"name":"result"}}],[11,"decode","","",1,{"inputs":[{"name":"value"},{"name":"decoder"}],"output":{"name":"result"}}],[11,"decode","","",8,{"inputs":[{"name":"bytestring"},{"name":"decoder"}],"output":{"name":"result"}}],[11,"decode","alloc::boxed","",10,{"inputs":[{"name":"box"},{"name":"decoder"}],"output":{"name":"result"}}],[11,"decode","alloc::rc","",11,{"inputs":[{"name":"rc"},{"name":"decoder"}],"output":{"name":"result"}}],[11,"decode","alloc::arc","",12,{"inputs":[{"name":"arc"},{"name":"decoder"}],"output":{"name":"result"}}],[11,"decode","collections::vec","",13,{"inputs":[{"name":"vec"},{"name":"decoder"}],"output":{"name":"result"}}],[11,"decode","collections::string","",14,{"inputs":[{"name":"string"},{"name":"decoder"}],"output":{"name":"result"}}],[11,"decode","collections::btree::map","",15,{"inputs":[{"name":"btreemap"},{"name":"decoder"}],"output":{"name":"result"}}],[11,"encode","bencode","",1,{"inputs":[{"name":"value"},{"name":"encoder"}],"output":{"name":"result"}}],[11,"encode","","",7,{"inputs":[{"name":"bytestr"},{"name":"encoder"}],"output":{"name":"result"}}],[11,"encode","","",8,{"inputs":[{"name":"bytestring"},{"name":"encoder"}],"output":{"name":"result"}}],[11,"encode","alloc::boxed","",10,{"inputs":[{"name":"box"},{"name":"encoder"}],"output":{"name":"result"}}],[11,"encode","alloc::rc","",11,{"inputs":[{"name":"rc"},{"name":"encoder"}],"output":{"name":"result"}}],[11,"encode","alloc::arc","",12,{"inputs":[{"name":"arc"},{"name":"encoder"}],"output":{"name":"result"}}],[11,"encode","collections::vec","",13,{"inputs":[{"name":"vec"},{"name":"encoder"}],"output":{"name":"result"}}],[11,"encode","collections::string","",14,{"inputs":[{"name":"string"},{"name":"encoder"}],"output":{"name":"result"}}],[11,"encode","collections::btree::map","",15,{"inputs":[{"name":"btreemap"},{"name":"encoder"}],"output":{"name":"result"}}]],"paths":[[4,"DecodeError"],[4,"Value"],[8,"Decodable"],[8,"Encodable"],[3,"Decoder"],[3,"Encoder"],[4,"EncodeError"],[3,"ByteStr"],[3,"ByteString"],[3,"Hash"],[3,"Box"],[3,"Rc"],[3,"Arc"],[3,"Vec"],[3,"String"],[3,"BTreeMap"]]};
searchIndex['sha1'] = {"items":[[0,"","sha1","A minimal implementation of SHA1 for rust.",null,null],[3,"Sha1","","Represents a Sha1 hash object in memory.",null,null],[11,"clone","","",0,{"inputs":[{"name":"sha1"}],"output":{"name":"sha1"}}],[11,"new","","Creates an fresh sha1 hash object.",0,{"inputs":[{"name":"sha1"}],"output":{"name":"sha1"}}],[11,"reset","","Resets the hash object to it's initial state.",0,{"inputs":[{"name":"sha1"}],"output":null}],[11,"update","","Update hash with input data.",0,null],[11,"output","","Retrieve digest result.  The output must be large enough to\ncontain result (20 bytes).",0,null],[11,"digest","","Shortcut for getting `output` into a new vector.",0,{"inputs":[{"name":"sha1"}],"output":{"name":"vec"}}],[11,"hexdigest","","Shortcut for getting a hex output of the vector.",0,{"inputs":[{"name":"sha1"}],"output":{"name":"string"}}]],"paths":[[3,"Sha1"]]};
searchIndex['byteorder'] = {"items":[[0,"","byteorder","This crate provides convenience methods for encoding and decoding numbers\nin either big-endian or little-endian order.",null,null],[4,"Error","","An error type for reading bytes.",null,null],[13,"UnexpectedEOF","","An unexpected EOF.",0,null],[13,"Io","","Any underlying IO error that occurs while reading bytes.",0,null],[4,"BigEndian","","Defines big-endian serialization.",null,null],[4,"LittleEndian","","Defines little-endian serialization.",null,null],[11,"fmt","","",0,{"inputs":[{"name":"error"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"from","","",0,{"inputs":[{"name":"error"},{"name":"error"}],"output":{"name":"error"}}],[11,"from","std::io::error","",1,{"inputs":[{"name":"error"},{"name":"error"}],"output":{"name":"error"}}],[11,"fmt","byteorder","",0,{"inputs":[{"name":"error"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"description","","",0,{"inputs":[{"name":"error"}],"output":{"name":"str"}}],[11,"cause","","",0,{"inputs":[{"name":"error"}],"output":{"name":"option"}}],[6,"Result","","A short-hand for `result::Result<T, byteorder::Error>`.",null,null],[6,"NativeEndian","","Defines system native-endian serialization.",null,null],[8,"ReadBytesExt","","Extends `Read` with methods for reading numbers. (For `std::io`.)",null,null],[11,"read_u8","","Reads an unsigned 8 bit integer from the underlying reader.",2,{"inputs":[{"name":"readbytesext"}],"output":{"name":"result"}}],[11,"read_i8","","Reads a signed 8 bit integer from the underlying reader.",2,{"inputs":[{"name":"readbytesext"}],"output":{"name":"result"}}],[11,"read_u16","","Reads an unsigned 16 bit integer from the underlying reader.",2,{"inputs":[{"name":"readbytesext"}],"output":{"name":"result"}}],[11,"read_i16","","Reads a signed 16 bit integer from the underlying reader.",2,{"inputs":[{"name":"readbytesext"}],"output":{"name":"result"}}],[11,"read_u32","","Reads an unsigned 32 bit integer from the underlying reader.",2,{"inputs":[{"name":"readbytesext"}],"output":{"name":"result"}}],[11,"read_i32","","Reads a signed 32 bit integer from the underlying reader.",2,{"inputs":[{"name":"readbytesext"}],"output":{"name":"result"}}],[11,"read_u64","","Reads an unsigned 64 bit integer from the underlying reader.",2,{"inputs":[{"name":"readbytesext"}],"output":{"name":"result"}}],[11,"read_i64","","Reads a signed 64 bit integer from the underlying reader.",2,{"inputs":[{"name":"readbytesext"}],"output":{"name":"result"}}],[11,"read_uint","","Reads an unsigned n-bytes integer from the underlying reader.",2,{"inputs":[{"name":"readbytesext"},{"name":"usize"}],"output":{"name":"result"}}],[11,"read_int","","Reads a signed n-bytes integer from the underlying reader.",2,{"inputs":[{"name":"readbytesext"},{"name":"usize"}],"output":{"name":"result"}}],[11,"read_f32","","Reads a IEEE754 single-precision (4 bytes) floating point number from\nthe underlying reader.",2,{"inputs":[{"name":"readbytesext"}],"output":{"name":"result"}}],[11,"read_f64","","Reads a IEEE754 double-precision (8 bytes) floating point number from\nthe underlying reader.",2,{"inputs":[{"name":"readbytesext"}],"output":{"name":"result"}}],[8,"WriteBytesExt","","Extends `Write` with methods for writing numbers. (For `std::io`.)",null,null],[11,"write_u8","","Writes an unsigned 8 bit integer to the underlying writer.",3,{"inputs":[{"name":"writebytesext"},{"name":"u8"}],"output":{"name":"result"}}],[11,"write_i8","","Writes a signed 8 bit integer to the underlying writer.",3,{"inputs":[{"name":"writebytesext"},{"name":"i8"}],"output":{"name":"result"}}],[11,"write_u16","","Writes an unsigned 16 bit integer to the underlying writer.",3,{"inputs":[{"name":"writebytesext"},{"name":"u16"}],"output":{"name":"result"}}],[11,"write_i16","","Writes a signed 16 bit integer to the underlying writer.",3,{"inputs":[{"name":"writebytesext"},{"name":"i16"}],"output":{"name":"result"}}],[11,"write_u32","","Writes an unsigned 32 bit integer to the underlying writer.",3,{"inputs":[{"name":"writebytesext"},{"name":"u32"}],"output":{"name":"result"}}],[11,"write_i32","","Writes a signed 32 bit integer to the underlying writer.",3,{"inputs":[{"name":"writebytesext"},{"name":"i32"}],"output":{"name":"result"}}],[11,"write_u64","","Writes an unsigned 64 bit integer to the underlying writer.",3,{"inputs":[{"name":"writebytesext"},{"name":"u64"}],"output":{"name":"result"}}],[11,"write_i64","","Writes a signed 64 bit integer to the underlying writer.",3,{"inputs":[{"name":"writebytesext"},{"name":"i64"}],"output":{"name":"result"}}],[11,"write_f32","","Writes a IEEE754 single-precision (4 bytes) floating point number to\nthe underlying writer.",3,{"inputs":[{"name":"writebytesext"},{"name":"f32"}],"output":{"name":"result"}}],[11,"write_f64","","Writes a IEEE754 double-precision (8 bytes) floating point number to\nthe underlying writer.",3,{"inputs":[{"name":"writebytesext"},{"name":"f64"}],"output":{"name":"result"}}],[8,"ByteOrder","","ByteOrder describes types that can serialize integers as bytes.",null,null],[10,"read_u16","","Reads an unsigned 16 bit integer from `buf`.",4,null],[10,"read_u32","","Reads an unsigned 32 bit integer from `buf`.",4,null],[10,"read_u64","","Reads an unsigned 64 bit integer from `buf`.",4,null],[10,"read_uint","","Reads an unsigned n-bytes integer from `buf`.",4,null],[10,"write_u16","","Writes an unsigned 16 bit integer `n` to `buf`.",4,null],[10,"write_u32","","Writes an unsigned 32 bit integer `n` to `buf`.",4,null],[10,"write_u64","","Writes an unsigned 64 bit integer `n` to `buf`.",4,null],[11,"read_i16","","Reads a signed 16 bit integer from `buf`.",4,null],[11,"read_i32","","Reads a signed 32 bit integer from `buf`.",4,null],[11,"read_i64","","Reads a signed 64 bit integer from `buf`.",4,null],[11,"read_int","","Reads a signed n-bytes integer from `buf`.",4,null],[11,"read_f32","","Reads a IEEE754 single-precision (4 bytes) floating point number.",4,null],[11,"read_f64","","Reads a IEEE754 double-precision (8 bytes) floating point number.",4,null],[11,"write_i16","","Writes a signed 16 bit integer `n` to `buf`.",4,null],[11,"write_i32","","Writes a signed 32 bit integer `n` to `buf`.",4,null],[11,"write_i64","","Writes a signed 64 bit integer `n` to `buf`.",4,null],[11,"write_f32","","Writes a IEEE754 single-precision (4 bytes) floating point number.",4,null],[11,"write_f64","","Writes a IEEE754 double-precision (8 bytes) floating point number.",4,null],[11,"read_u16","","",5,null],[11,"read_u32","","",5,null],[11,"read_u64","","",5,null],[11,"read_uint","","",5,null],[11,"write_u16","","",5,null],[11,"write_u32","","",5,null],[11,"write_u64","","",5,null],[11,"read_u16","","",6,null],[11,"read_u32","","",6,null],[11,"read_u64","","",6,null],[11,"read_uint","","",6,null],[11,"write_u16","","",6,null],[11,"write_u32","","",6,null],[11,"write_u64","","",6,null],[11,"read_u8","","Reads an unsigned 8 bit integer from the underlying reader.",2,null],[11,"read_i8","","Reads a signed 8 bit integer from the underlying reader.",2,null],[11,"read_u16","","Reads an unsigned 16 bit integer from the underlying reader.",2,null],[11,"read_i16","","Reads a signed 16 bit integer from the underlying reader.",2,null],[11,"read_u32","","Reads an unsigned 32 bit integer from the underlying reader.",2,null],[11,"read_i32","","Reads a signed 32 bit integer from the underlying reader.",2,null],[11,"read_u64","","Reads an unsigned 64 bit integer from the underlying reader.",2,null],[11,"read_i64","","Reads a signed 64 bit integer from the underlying reader.",2,null],[11,"read_uint","","Reads an unsigned n-bytes integer from the underlying reader.",2,null],[11,"read_int","","Reads a signed n-bytes integer from the underlying reader.",2,null],[11,"read_f32","","Reads a IEEE754 single-precision (4 bytes) floating point number from\nthe underlying reader.",2,null],[11,"read_f64","","Reads a IEEE754 double-precision (8 bytes) floating point number from\nthe underlying reader.",2,null],[11,"write_u8","","Writes an unsigned 8 bit integer to the underlying writer.",3,null],[11,"write_i8","","Writes a signed 8 bit integer to the underlying writer.",3,null],[11,"write_u16","","Writes an unsigned 16 bit integer to the underlying writer.",3,null],[11,"write_i16","","Writes a signed 16 bit integer to the underlying writer.",3,null],[11,"write_u32","","Writes an unsigned 32 bit integer to the underlying writer.",3,null],[11,"write_i32","","Writes a signed 32 bit integer to the underlying writer.",3,null],[11,"write_u64","","Writes an unsigned 64 bit integer to the underlying writer.",3,null],[11,"write_i64","","Writes a signed 64 bit integer to the underlying writer.",3,null],[11,"write_f32","","Writes a IEEE754 single-precision (4 bytes) floating point number to\nthe underlying writer.",3,null],[11,"write_f64","","Writes a IEEE754 double-precision (8 bytes) floating point number to\nthe underlying writer.",3,null]],"paths":[[4,"Error"],[3,"Error"],[8,"ReadBytesExt"],[8,"WriteBytesExt"],[8,"ByteOrder"],[4,"BigEndian"],[4,"LittleEndian"]]};
initSearch(searchIndex);
